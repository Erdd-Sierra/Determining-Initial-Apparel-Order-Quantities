# Role
あなたはサプライチェーン・マネジメント（SCM）の最適化を行うPythonエキスパートです。
Streamlitを用いたシミュレーションツールを作成してください。

# Goal
アパレル商品の発注において、「香港工場」と「中国工場」それぞれでどれくらい初期生産すべきかを意思決定するためのツールを開発します。
不確実な需要のもとで、モンテカルロシミュレーションを用いて最適な発注量を算出します。

# Tech Stack
- Python 3.10+
- Streamlit (GUI: st.tabsを使用)
- PuLP (線形計画法ソルバー)
- Pandas, NumPy
- Plotly (可視化)

# Data Definition (Hardcoded)
以下のデータをコード内の定数（リストまたは辞書）として定義してください。
※CSV読み込みは不要です。

## 1. 商品データ
各商品のパラメータは以下の通りです。
- `Mean`: 平均需要 ($\mu$)
- `StdDev`: 需要の標準偏差 ($\sigma$) ※この値を使用する
- `Price`: 卸売価格
- `UnderageCost`: 機会損失単価 ($0.24 \times Price$)
- `OverageCost`: 売れ残り損失単価 ($0.08 \times Price$)

PRODUCTS = [
    {"Style": "Gail",      "Price": 110, "Mean": 1017, "StdDev": 388,   "UnderageCost": 26.40, "OverageCost": 8.80},
    {"Style": "Isis",      "Price": 99,  "Mean": 1042, "StdDev": 646,   "UnderageCost": 23.76, "OverageCost": 7.92},
    {"Style": "Entice",    "Price": 80,  "Mean": 1358, "StdDev": 496,   "UnderageCost": 19.20, "OverageCost": 6.40},
    {"Style": "Assault",   "Price": 90,  "Mean": 2525, "StdDev": 680,   "UnderageCost": 21.60, "OverageCost": 7.20},
    {"Style": "Teri",      "Price": 123, "Mean": 1100, "StdDev": 762,   "UnderageCost": 29.52, "OverageCost": 9.84},
    {"Style": "Electra",   "Price": 173, "Mean": 2150, "StdDev": 807,   "UnderageCost": 41.52, "OverageCost": 13.84},
    {"Style": "Stephanie", "Price": 133, "Mean": 1113, "StdDev": 1048,  "UnderageCost": 31.92, "OverageCost": 10.64},
    {"Style": "Seduced",   "Price": 73,  "Mean": 4017, "StdDev": 1113,  "UnderageCost": 17.52, "OverageCost": 5.84},
    {"Style": "Anita",     "Price": 93,  "Mean": 3296, "StdDev": 2094,  "UnderageCost": 22.32, "OverageCost": 7.44},
    {"Style": "Daphne",    "Price": 148, "Mean": 2383, "StdDev": 1394,  "UnderageCost": 35.52, "OverageCost": 11.84},
]

# 3. シミュレーションと最適化ロジック

## 3.1 モンテカルロシミュレーション
ボタン「シミュレーション実行」を押すと、指定回数 $n$ (デフォルト100回程度) のループを実行する。

### ループ内の処理 ($i = 1 \dots n$)
1. **需要生成**: 三角分布に従って各商品の需要 $D_i$ を生成する。
2. **最適化問題 (MIP) を解く**: 混合整数計画法を用いて最適発注量を決定
3. **結果保存**: この回での最適発注量 $x_i^*$ と、その時の損失額を保存する。

## 3.2 需要生成（三角分布）

各商品 $j$ の需要 $D_j$ は、以下のパラメータを持つ三角分布から生成される：

- **頂点（最頻値）**: $\mu_j$ (平均需要)
- **最小値**: $\max(0, \mu_j - \sigma_j)$
- **最大値**: $\mu_j + \sigma_j$

確率密度関数：
$$f(x) = \begin{cases}
\frac{2(x-a)}{(b-a)(c-a)} & \text{if } a \leq x < c \\
\frac{2(b-x)}{(b-a)(b-c)} & \text{if } c \leq x \leq b \\
0 & \text{otherwise}
\end{cases}$$

ここで、$a = \max(0, \mu - \sigma)$, $b = \mu + \sigma$, $c = \mu$ である。

## 3.3 最適化問題（混合整数計画法：MIP）

### 3.3.1 決定変数

- **連続変数 $x_j$**: 商品 $j$ の発注量（$j = 1, \ldots, m$）
- **バイナリ変数 $y_j$**: 商品 $j$ を発注するかどうか
  - $y_j = 1$: 商品 $j$ を発注する
  - $y_j = 0$: 商品 $j$ を発注しない
- **補助変数**:
  - $s_j$: 商品 $j$ の不足量（需要 > 発注量の場合）
  - $e_j$: 商品 $j$ の余剰量（発注量 > 需要の場合）

### 3.3.2 目的関数（最小化）

総損失を最小化する：

$$\min \sum_{j=1}^{m} \left( C_u^j \cdot s_j + C_o^j \cdot e_j \right)$$

ここで：
- $C_u^j = 0.24 \times P_j$: 商品 $j$ の機会損失単価（卸売価格の24%）
- $C_o^j = 0.08 \times P_j$: 商品 $j$ の売れ残り損失単価（卸売価格の8%）
- $P_j$: 商品 $j$ の卸売価格

**損失の定義**:
- **機会損失**: 需要が発注量を上回る場合の損失（売り逃し）
  - $s_j = \max(0, D_j - x_j)$
- **売れ残り損失**: 発注量が需要を上回る場合の損失（在庫処分）
  - $e_j = \max(0, x_j - D_j)$

### 3.3.3 制約条件

#### (1) 不足量・余剰量の定義
$$x_j - D_j = s_j - e_j, \quad \forall j$$

この制約により、$s_j$ と $e_j$ のうち一方のみが正の値を持つことが保証される。

#### (2) 合計発注量制約（等式制約）
$$\sum_{j=1}^{m} x_j = 10,000$$

合計発注量は厳密に10,000とする（最大かつ最小）。

#### (3) 「0または最小ロット数以上」の制約（Big-M法）

各商品について、発注量は**0**または**最小ロット数以上**でなければならない：

$$x_j = 0 \quad \text{または} \quad x_j \geq L_j$$

ここで、$L_j$ は商品 $j$ の最小ロット数（香港工場: 600、中国工場: 1200）。

この制約を線形計画法の形式で表現するために、**Big-M法**を使用する：

**Big-M法による定式化**:

1. バイナリ変数 $y_j$ を導入：
   - $y_j = 1$: 商品 $j$ を発注する
   - $y_j = 0$: 商品 $j$ を発注しない

2. 以下の2つの制約を追加：
   $$x_j \geq L_j \cdot y_j$$
   $$x_j \leq M \cdot y_j$$

ここで、$M$ は十分大きな数（本問題では $M = 10,000$ を使用）。

**制約の動作**:
- $y_j = 1$ の場合:
  - $x_j \geq L_j$（最小ロット数以上）
  - $x_j \leq M$（上限制約）
- $y_j = 0$ の場合:
  - $x_j \geq 0$（非負制約のみ）
  - $x_j \leq 0$（つまり $x_j = 0$）

これにより、$x_j = 0$ または $x_j \geq L_j$ が保証される。

**なぜ上限制約 $x_j \leq M \cdot y_j$ が必要なのか？**

1. **$y_j = 0$ のとき $x_j = 0$ を強制するため**:
   - $x_j \geq L_j \cdot y_j = L_j \cdot 0 = 0$ だけでは、$x_j$ が正の値になる可能性がある
   - $x_j \leq M \cdot y_j = M \cdot 0 = 0$ により、$x_j = 0$ が強制される

2. **$y_j = 1$ のときの上限制約として機能**:
   - 理論的には、$x_j \geq L_j \cdot y_j$ だけでは $x_j$ がどこまで大きくなれるかが不明確
   - $x_j \leq M \cdot y_j = M$ により、各変数の実現可能な上限を明示
   - ただし、$M$ は**実現可能な最大値以上**である必要がある（そうでないと、最適解が除外される可能性がある）

3. **本問題における $M$ の選択**:
   - 合計発注量が10,000に固定されているため、各商品の発注量は自動的に10,000以下
   - したがって、$M = 10,000$ は安全な選択（実現可能な上限を超えている）
   - より厳密には、$M$ は各商品の実現可能な最大発注量（例: 10,000）以上であれば良い

**Big-M法の一般的な原則**:
- $M$ は「十分大きな数」である必要があるが、**大きすぎると数値的な問題を引き起こす可能性がある**
- 理想的には、$M$ は変数の実現可能な上限にできるだけ近い値に設定する
- 本問題では、合計発注量制約により自動的に上限が決まるため、$M = 10,000$ は適切

#### (4) 非負制約
$$x_j \geq 0, \quad s_j \geq 0, \quad e_j \geq 0, \quad \forall j$$
$$y_j \in \{0, 1\}, \quad \forall j$$

### 3.3.4 混合整数計画法（MIP）について

本問題は**混合整数計画問題（Mixed Integer Programming, MIP）**である：
- 連続変数: $x_j$, $s_j$, $e_j$
- 整数変数（バイナリ）: $y_j$

PuLPは、このような混合整数計画問題を解くためのソルバー（CBC、GLPK等）を使用する。

## 3.4 モンテカルロシミュレーションの理論

モンテカルロシミュレーションは、不確実性を含む問題に対して統計的な解を求める手法である。

1. **$n$回のシミュレーション実行**: 各回で異なる需要を生成
2. **各回で最適化**: 生成された需要に対して最適発注量を計算
3. **統計的集約**: $n$回の結果から推奨値を算出
   - 推奨発注量: $\bar{x}_j = \frac{1}{n} \sum_{i=1}^{n} x_{ij}^*$
   - ここで、$x_{ij}^*$ は $i$ 回目のシミュレーションで商品 $j$ に対して得られた最適発注量

**大数の法則**: $n$ が大きくなるほど、推奨値は真の期待値に近づく。

## 4. 出力結果
シミュレーション終了後、以下の数値を計算して表示する。

1. **推奨発注量**: $n$回のシミュレーションで得られた「最適発注量」の**平均値**。
   $$\bar{x}_j = \frac{1}{n} \sum_{i=1}^{n} x_{ij}^*$$
   ここで、$x_{ij}^*$ は $i$ 回目のシミュレーションで商品 $j$ に対して得られた最適発注量。

2. **損失分布**: $n$回の試行における損失額のヒストグラム。
   - 各シミュレーション回 $i$ での損失: $L_i = \sum_{j=1}^{m} (C_u^j \cdot s_{ij} + C_o^j \cdot e_{ij})$

3. **統計情報**:
   - 平均損失: $\bar{L} = \frac{1}{n} \sum_{i=1}^{n} L_i$
   - 最小損失: $L_{\min} = \min_i L_i$
   - 最大損失: $L_{\max} = \max_i L_i$
   - 標準偏差: $\sigma_L = \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (L_i - \bar{L})^2}$

# Note
- 香港と中国でそれぞれ独立して計算を行うこと。
- データはコード内に見やすく `CONFIG` 変数などの形でまとめて記述し、後で値を調整しやすくすること。

